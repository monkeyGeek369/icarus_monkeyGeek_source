---
title: jvm内存模型
category: jvm
date: 2022-06-18 15:02:04
updated: 2022-06-18 15:02:04
enname: memory
categories: jvm
tags:
	- 面试
	- jvm
keywords: jvm内存模型
permalink:
thumbnail:
---

# 简介

运行时数据区整体结构如下：

- 程序计数器<!--more-->
- 虚拟机栈
- 本地方法栈
- 堆
- 方法区（永久代/metaspace）



</br></br></br>

# CPU基础知识

### CPU缓存

- 一级缓存：cup内核有独立一级缓存
- 二级缓存：cup内核有独立二级缓存
- 三级缓存：cup内核共享三级缓存，会存在一致性问题



### 缓存一致性问题解决

- 总线锁：cpu取值时对总线上锁
- 缓存一致性协议MESI协议：modify/exclusive/shared/invalid，简单来讲cpu会对读写的数据进行四种状态的标记，不同的状态处理的方式不同。（无法被缓存的数据或者夸缓存行的数据MESI无法解决，还是要靠总线锁）



### 缓存行

- 目的：读区数据时进行缓存行cache line整行读区（主流一行64字节），提高效率。
- 伪共享问题：同一缓存行内的不同数据被不同cpu使用锁定，当数据被改动后，整个缓存行会被告知修改，不同cpu重新读区，造成互相影响
- 缓存行对齐提效：利用缓存行64字节以及整行读写的特点，利用“padding+真实数据 = 64字节”的方式提升真实数据对象的读写操作



### 乱序问题

- 并行执行：当两条指令没有依赖关系，cpu会并行执行
- 合并写：写操作有可能会放在一起合并操作
- 指令重排序：两条互相不影响的指令有可能被重新排序执行



### 有序性保证

- cpu内存屏障
  - sfence:写屏障，屏障前后的写操作不能重排
  - lfence:读屏障，屏障前后的读操作不能重排
  - mfence:读写屏障，屏障前后的读写操作不能重排
- lock指令



### 并行与并发

- 串行：以垃圾回收为例，串行回收器只有一个垃圾回收线程，执行时用户线程无法执行
- 并行：以垃圾回收为例，并行回收器可以有多个垃圾回收线程，执行时用户线程无法执行
- 并发：以垃圾回收为例，并发回收器可以有多个垃圾回收线程，执行时用户线程可以同时执行。例如采用时间片轮训的方式



</br></br></br>

# 线程共享

### 堆

- JVM启动（程序启动）时被创建，是jvm中最重要、最大的一块内存空间
- 可以物理上不连续但逻辑是连续
- 所有线程共享，但可以对不同线程划分私有缓存区TLAB
- 存放对象、数组、class对象信息等



#### 堆的内存结构

- 年轻代
- 年老代
- 永久代/方法区/元数据区：java8及以后已经不属于堆



#### 堆空间大小的设置

- -Xms：设置堆初始内存 memory star，-Xms600m，默认是物理内存1/64
- -Xmx：设置堆最大内存 memory max，-Xmx600m，默认是物理内存1/4
- 建议初始和最大设置一样，避免堆内存动态变化导致的资源浪费



</br>

### 方法区

- 也称"***永久代***"，用于***\*存储虚拟机加载的类信息、常量、静态变量\****
- 默认最小值为16MB，最大值为64MB（64位JVM由于指针膨胀，默认是85M）
- 它是***\*一片连续的堆空间\****，并与堆空间连续
- 垃圾收集是和老年代(old generation)捆绑在一起的，无论谁满了都会一起回收
- 从JDK7***\*开始移除永久代（但并没有移除）\****



</br>

### 运行时常量池

- 是方法区的一部分
- 用于***\*存放编译器生成的各种符号引用\****

</br>

### 元数据区

- JDK8开始使用元空间（Metaspace），方法区存在于元空间
- 元空间不再与堆连续，而是存在于本地内存
- 本地内存（Native memory），也称为C-Heap，是供JVM自身进程使用的。当Java Heap空间不足时会触发GC，但Native memory空间不够却不会触发GC。
- 默认情况下元空间是可以无限使用本地内存的，但是也可以通过参数进行设置



</br>

# 线程私有

### 程序计数器

用来存储指向下一条指令的地址，由执行引擎读取下一条指令执行

- 程序计数器存在的意义？cpu在不停的切换线程执行，因此需要记录下一条可以执行的指令
- 为什么是线程私有的？如果不是私有会存在一致性问题



</br>

### 虚拟机栈

#### 特点

- 线程私有
- 生命周期与线程一致
- 不存在垃圾回收问题



#### 可能出现的异常

栈大小可以是固定的也可以是动态的

- Stackoverflowerror:当栈大小是固定的时候，有可能出现此问题
- Outofmemoryerror:当栈大小是动态的时候，请求增加栈空间有可能报此问题

可以通过-Xss设置栈大小，如-Xss1m



#### 栈的存储结构

栈的基本单位就是栈贞，java方法的执行就是栈贞入栈到出栈的过程，栈贞的具体结构如下

- 局部变量表
- 操作数栈
- 动态链接
- 方法返回地址
- 一些附加信息



#### 局部变量表

- 局部变量表在编译期就确定下来
- 定义为一个数字数组
- 存放方法参数、方法中的局部变量，例如基本数据类型、对象饮用、returnaddress类型等
- 基本存储单位是slot（槽）
- 32位以内类型占一个slot，如byte\short\char\int\boolen
- 64位占两个slot，如long\double

```
#### 变量的分类
- 按数据类型
  - 基本数据类型
  - 引用数据类型
- 按在类中声明的位置
  - 成员变量：在使用前都经历过赋默认值的过程
    - 类变量：链接阶段赋默认值
    - 实例变量：随着对象的创建会在堆内存分配空间并赋默认值
  - 局部变量：在使用前必须显式赋值，否则编译不通过
```



#### 操作数栈

- 结构：数组/链表，先入后出
- 作用：在方法执行的过程中，根据字节码指令，往操作数栈中写入或读区指令。简单来说就是存放操作数、运算中间数据的容器
- 特点：长度在编译时确定
- 使用过程：例如1+2的操作，1和2分别压入操作数栈，通过add指令进行求和，结果根据istore_1指令存放入局部变量表的index为1的位置。



#### 贞数据区

1. 动态链接：栈贞中存储的一个内存地址，这个地址指向方法区中运行常量池记录的方法引用，即指向具体的方法。

   1. 每一个栈贞都记录本栈贞对应的运行常量池方法引用（动态链接）
   2. 栈贞中调用了其它方法时也会记录指向被调用方法的运行常量池方法引用（动态链接）

2. 方法返回地址

   1. 保存调用该方法的pc寄存器的值

   2. 目的：为了指向方法执行结束后的下一条指令，即返回到该方法被调用的位置

   3. 方法的退出方式

      1. 正常退出：返回该方法被调用的位置
      2. 异常退出：通过异常表来确定返回地址

   4. 返回命令

      ```
      ireturn：返回值是boolen、byte、char、short、int
      Lreturn：long类型
      freturn：float类型
      dreturn：double类型
      areturn：引用类型
      return：void
      ```

      

3. 一些附加信息：例如对程序调试提供支持的信息等，具体要看虚拟机的实现，不一定都有。



#### 常见问题

- 方法中定义的局部变量是不是线程安全的？具体问题具体分析
  - 如果涉及到将局部变量返回则有可能不安全
  - 如果是参数传递进来的有可能不安全

</br>

### 本地方法栈

- 本地方法：一个java方法，但是实现不是由java实现而是其它语言，如c/c++
- 为什么使用本地方法？与java环境外交互、与操作系统交互
- 本地方法栈：管理本地方法的调用，其他与虚拟机栈相同



</br>

</br>

</br>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<div style="height:260px; background-color:rgb(238,240,244); padding:10px;border-radius:10px;">
    <p style="color:#f36c21;font:bold 16px/20px 'kaiTi';">
      版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!!
    </p>
    <p>
      <span style="font:bold 16px/20px 'kaiTi';">本文出自：</span><a href="https://monkeyGeek369.github.io">monkeyGeek</a> 
    </p>
    <p>
      <span style="font:bold 16px/20px 'kaiTi';">座右铭：</span><span>生于忧患，死于安乐</span> 
    </p>
    <p>
      <span style="font:16px/20px 'kaiTi';">欢迎志同道合的朋友一起交流、探讨！</span> 
    </p>
    <img style="height:auto; width:auto;flot:left;" src="../../../../image/monkey64.png" /><span style="font:16px/20px 'kaiTi';flot:left;">   monkeyGeek</span>


