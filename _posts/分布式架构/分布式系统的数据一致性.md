---
title: 分布式系统的数据一致性
category: 分布式架构
date: 2019-11-25 19:27:16
updated: 2019-11-25 19:27:16
enname: dataconsistency
categories: 分布式架构
tags:
	- 分布式
	- 数据一致性
	- 事务
keywords: 分布式,base理论,CAP理论,数据一致性,事务
permalink:
thumbnail:
---

</br>

# 一 什么是事务?

事务一词是新兴词汇,从字面意思来看可能会感觉比较晦涩陌生,但是在软件行业这个词还是听的挺多的.事务无处不在,先来举个小栗子,比如我们要去逛超市购物那么需要先推一辆车再选购商品,再支付,而这整个流程就是事务.<!--more-->再例如支付这个节点也可以分为掏出手机,打开支付宝/微信,完成扫描,支付成功,这一整个过程又可以看作一个事务,其实我们看不到的还有支付宝内部的一连串处理节点,也是其自身的事务等等等......

通过上面的简单举例我们可以看出事务有如下特性:

- 事务的最终目的是完成某件事或实现某目标
- 事务可被拆分为更小的组成单元/步骤,即事务是一种特殊的集合
- 事务集合中任何节点的失败都将造成整个事务的失败

</br>

# 二 事务的起源

 提到事务不得不提到「**XA规范**」，详情可参考[XA分布式事务原理](http://www.monkeygeek.cn/2019/11/26/xaTransaction/)

</br>

# 三 CAP理论

事务问题其实一直存在，只是在分布式系统中被放大了。并且随着系统拆分的粒度越细，问题的复杂度成指数上升。

「CAP」理论由Eric Brewer在2000年PODC会议上提出，所以还被称为Brewer定理。是Eric Brewer在Inktomi期间研发搜索引擎、分布式web缓存时得出的一个猜想,后来Seth Gilbert和Nancy Lynch对其进行了证明[3]，成为我们熟知的「CAP」定理.

> It is impossible for a web service to provide the three following guarantees : Consistency, Availability and Partition-tolerance.

详情可参考[CAP理论](http://www.monkeygeek.cn/2019/11/27/cap/)

</br>

# 四 BASE理论

详情可参考[BASE理论](http://www.monkeygeek.cn/2019/11/27/base/)

</br>

# 五 分布式事务的常见解决方案

CAP理论以及BASE理论只是思想指导,基于这两种理论发展出一系列解决方案,每种方案的侧重点各有不同.

### 5.1 两阶段提交(2PC)

![](../../../../image/2pc.png)

这是最简单的分布式事务解决方案,通过设立协调者来处理事务不同处理节点的相互关系.



<span style="color:red;">**两个阶段的执行**</span>

1.请求阶段
在请求阶段，协调者将通知事务参与者准备提交或取消事务，然后进入表决过程。
在表决过程中，参与者将告知协调者自己的决策：同意（事务参与者本地作业执行成功）或取消（本地作业执行故障）。

2.提交阶段
在该阶段，协调者将基于第一个阶段的投票结果进行决策：提交或取消。
当且仅当所有的参与者同意提交事务协调者才通知所有的参与者提交事务，否则协调者将通知所有的参与者取消事务。
参与者在接收到协调者发来的消息后将执行响应的操作。



<span style="color:red;">**两阶段提交的缺点**</span>

1.同步阻塞问题。执行过程中，所有参与节点都是事务阻塞型的。
当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。

2.单点故障。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）

3.数据不一致。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这讲导致只有一部分参与者接受到了commit请求。
而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。



<span style="color:red;">**两阶段提交无法解决的问题**</span>

当协调者出错，同时参与者也出错时，两阶段无法保证事务执行的完整性。
考虑协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。
那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。



以CAP理论为基础的解决方案通常会出现一个类似"协调者"的服务对象

</br>

本文部分内容参考:

https://www.imooc.com/article/75228

https://www.cnblogs.com/AndyAo/p/8228099.html

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<div style="height:260px; background-color:rgb(238,240,244); padding:10px;border-radius:10px;">
    <p style="color:#f36c21;font:bold 16px/20px 'kaiTi';">
      版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!!
    </p>
    <p>
      <span style="font:bold 16px/20px 'kaiTi';">本文出自：</span><a href="https://monkeyGeek369.github.io">monkeyGeek</a> 
    </p>
    <p>
      <span style="font:bold 16px/20px 'kaiTi';">座右铭：</span><span>生于忧患，死于安乐</span> 
    </p>
    <p>
      <span style="font:16px/20px 'kaiTi';">欢迎志同道合的朋友一起交流、探讨！</span> 
    </p>
    <img style="height:auto; width:auto;flot:left;" src="../../../../image/monkey64.png" /><span style="font:16px/20px 'kaiTi';flot:left;">   monkeyGeek</span>


